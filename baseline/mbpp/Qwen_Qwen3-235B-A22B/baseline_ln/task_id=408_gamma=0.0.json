{
  "code": "import heapq\n\ndef k_smallest_pairs(nums1, nums2, k):\n    if not nums1 or not nums2 or k <= 0:\n        return []\n    \n    heap = []\n    visited = set()\n    \n    # Initialize the heap with the first element of nums1 and first element of nums2\n    heapq.heappush(heap, (nums1[0] + nums2[0], 0, 0))\n    visited.add((0, 0))\n    \n    result = []\n    \n    while heap and len(result) < k:\n        sum_val, i, j = heapq.heappop(heap)\n        result.append([nums1[i], nums2[j]])\n        \n        # Move to the next element in nums1, keeping nums2 index same\n        if i + 1 < len(nums1) and (i + 1, j) not in visited:\n            heapq.heappush(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n            visited.add((i + 1, j))\n        \n        # Move to the next element in nums2, keeping nums1 index same\n        if j + 1 < len(nums2) and (i, j + 1) not in visited:\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n            visited.add((i, j + 1))\n    \n    return result",
  "results": {
    "assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]": {
      "result": true,
      "time": 0.11104798316955566,
      "error": null
    },
    "assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]": {
      "result": true,
      "time": 0.09257698059082031,
      "error": null
    },
    "assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]": {
      "result": true,
      "time": 0.0834817886352539,
      "error": null
    }
  },
  "passed": true,
  "accuracy": 1.0,
  "general_error": null,
  "has_testcase_error": false,
  "stats": {
    "start_time": "2025-05-08 22:58:36",
    "end_time": "2025-05-08 22:58:41",
    "duration": "0:00:05.022644"
  },
  "retry": 0,
  "random_seed": 855
}